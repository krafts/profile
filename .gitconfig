[core]
  editor = vim #atom --wait
  excludesfile = ~/.gitignore_global
  mergeoptions = --no-edit
#  pager = diff-so-fancy | less --tabs=4 -RFX
[push]
  default = simple

[merge]
  tool = vimdiff

[mergetool]
  prompt = false
 
[diff]
  tool = sublimerge
 
[difftool "sublimerge"]
  cmd = subl -n --wait \"$REMOTE\" \"$LOCAL\" --command \"sublimerge_diff_views {\\\"left_read_only\\\": true, \\\"right_read_only\\\": true}\"

#[credential]
#  helper = osxkeychain
 
[alias]
  ecg = config --global -e
  ecl = config --local -e
  ci = commit
  b = branch
  bra = branch --all
  co = checkout
  a = add
  air = add --ignore-removal
  rs = reset
  df = diff
  dc = diff --cached
  dfs = diff --stat
  dcs = diff --cached --stat
  who = shortlog -s --
  cl = clean
  clf = clean -f
  cld = clean -d
  clfd = clean -fd
  cliff = clean -f
  cliffd = clean -fd
  k = !gitk -all&
  ft = fetch
  mg = merge
  pl = pull --rebase
  po = pull --rebase origin
  ps = push
  bl = blame -n
  s = status --short --branch
  fs = "!_() { git co develop && git pl && git flow feature start \"$@\" && git fp; }; _"
  fp = "!git flow feature publish $(git rev-parse --abbrev-ref HEAD | sed 's/feature\\///g')"
  fr = "!_() { b=$(git rev-parse --abbrev-ref HEAD) && if echo $b | grep -vq -e ^feature 2>&1>/dev/null; then echo \"$b is not a feature, cannot proceed\"; exit 1; fi && git co develop && git pl && git co $b && git flow feature rebase && git psf; }; _"
  poo = "!_() { branch=\"$@\"; if [ $(git bra | grep  \"remotes/origin/$branch\" | wc -l) -le 0 ]; then echo "$branch does not exist on origin"; exit 0; fi; printf \"DELETE $branch on origin! [y/N]: \"; read answer; if echo "$answer" | grep -iq "^y"; then git push origin :$branch; fi; }; _"
  dodo = "!git poo $(git rev-parse --abbrev-ref HEAD)"
  lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cI %cr) %C(bold blue)<%an>%Creset'
  lgr = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'
  abbr = "!sh -c 'git rev-list --all | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:\"%H %ci %an %s%n\" $commit; done' -"
#  abbrbr = "!sh -c 'git rev-list --branches --reverse | grep ^$1 | while read commit; do git --no-pager log -n1 --pretty=format:\"%C(yellow)%d%Creset %H %ci %an %s%n\" $commit; done' -"
  oneline = "!_() { $(test $# -eq 0 && echo xargs -L1) git log --no-walk --decorate --oneline \"$@\"; }; _"
  tips = "!_() { t=$(git rev-list --no-merges --max-count=1 \"$@\"); if test -n \"$t\"; then echo $t; _ \"$@\" ^$t; fi; }; _"
  forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
  alias = config --get-regexp ^alias\\.
  sob = "!_() { git branch --remotes | grep -vi head | while read i; do git --no-pager log -n1 --pretty=format:\"%Cgreen%ci%Creset %Cred%H%Creset %C(yellow)%d%Creset  %an %s%n\" $i ;  done  | sort -n; }; _"
  sobr = "!_() { git branch --remotes | grep -vi head | while read i; do git --no-pager log -n1 --pretty=format:\"%Cgreen%ci%Creset %Cred%H%Creset %C(yellow)%d%Creset  %an %s%n\" $i ;  done  | sort -nr; }; _"
  st = stash
  stop = stash pop
  slap = stash apply
  still = stash list
  info = remote -v
  rc = rebase --continue
  ra = rebase --abort
  sh = show
  hf = "!_() { b=$(git rev-parse --abbrev-ref HEAD) && git hr && git co develop && git pl && git co $b && h=$(echo $b | sed 's/hotfix\\///g') && git flow hotfix finish -m hotfix_finished_on_$(date +'%Y-%m-%dT%H:%M:%S%z') $h && git co master && git ps && git co develop && git ps && git ps --tags && git poo $b && git dlb $b; }; _"
  hs = "!_() { git co  master && git pl && git flow hotfix start \"$@\" && git hp; }; _"
  hr = "!_() { b=$(git rev-parse --abbrev-ref HEAD) && if echo $b | grep -vq ^hotfix 2>&1>/dev/null; then echo \"$b is not a hotfix, cannot proceed\"; exit 1; fi && git co master && git pl && git co $b && git rebase master && git psf; }; _"
  hp = "!_() { git push --set-upstream origin $(git rev-parse --abbrev-ref HEAD); }; _"
  cr = diff develop -U30

  crh = diff master -U30
  ff = "!_() { b=$(git rev-parse --abbrev-ref HEAD) && git fr && git flow feature finish $(echo $b | sed 's/feature\\///g') && git ps && git poo $b && git dlb $b; }; _"
  punt = "!_() { git remote prune origin && git branch -vv | grep ': gone] ' | awk '{print $1}' | xargs git branch -D; }; _"
  dlb = "!_() { branch=\"$@\" && git rev-parse --verify --quiet \"$branch\" 2>&1>/dev/null && git b -D \"$branch\"; }; _"
  psf = "!_() { branch=$(git rev-parse --abbrev-ref HEAD); if [ \"$branch\" == \"develop\" ]; then echo \"cannot force push develop\"; exit 1; elif [ \"$branch\" == \"master\" ]; then echo \"cannot force push master\"; exit 1; else git ps --force; fi; }; _"
  account = "!_() { git remote -v | awk -F':' '{print $2}' | awk '{print $1}' | awk -F'/' '{print $1}' | sort | uniq | head -1; }; _"
  repo = "!_() { git remote -v | awk -F':' '{print $2}' | awk '{print $1}' | awk -F'/' '{print $2}' | awk -F'.' '{print $1}' | sort | uniq | head -1; }; _"
  prbase = "!_() { b=$(git rev-parse --abbrev-ref HEAD) && if echo $b | grep -q ^hotfix 2>&1>/dev/null; then echo master; elif echo $b | grep -q ^feature 2>&1>/dev/null; then echo develop; fi; }; _"
  brn = rev-parse --abbrev-ref HEAD
  pr = "!_() { b=$(git brn) && pr_base=$(git prbase) && token=$(cat ~/.github_git_alias_auth_token) && if echo $b | grep -vq -e ^hotfix -e ^feature 2>&1>/dev/null; then echo \"not a hotfix or feature, cannot create pull request.\"; exit 1; fi && curl -H \"Authorization: token $token\" -H \"Content-Type: application/json\" --data \"{ \\\"title\\\": \\\"$b\\\", \\\"body\\\": \\\"$(git log --oneline --abbrev-commit $b ^$pr_base --no-merges | sed 's/$/\\\\\\\\\\\\n/' | tr -d '\\n')\\\", \\\"head\\\": \\\"$b\\\", \\\"base\\\": \\\"$pr_base\\\" }\" https://api.github.com/repos/$(git account)/$(git repo)/pulls; }; _"
  commend = commit --amend --no-edit
  #pr = "!_() { b=$(git brn) && token=$(cat ~/.github_git_alias_auth_token) && if echo $b | grep -vq -e ^hotfix -e ^feature 2>&1>/dev/null; then echo \"not a hotfix or feature, cannot create pull request.\"; exit 1; fi && curl -H \"Authorization: token $token\" -H \"Content-Type: application/json\" --data \"{ \\\"title\\\": \\\"$b\\\", \\\"body\\\": \\\"Please pull this in!\\\", \\\"head\\\": \\\"$b\\\", \\\"base\\\": \\\"$(git prbase)\\\", \\\"assignees\\\": [ $(cat ~/.github_git_alias_assignee_list) ] }\" https://api.github.com/repos/$(git account)/$(git repo)/pulls; }; _"
  ar = "!_() { branch=$(git brn) && if [ \"$branch\" == \"master\" ]; then echo \"cannot rebase master into master\"; exit 1; fi && git pl && git co master && git pl && git co $branch && git rebase master && git psf; }; _"
  af = "!_() { branch=$(git brn) && if [ \"$branch\" == \"master\" ]; then echo \"cannot merge master into master\"; exit 1; fi && git ar && git co master && git merge --no-ff $branch && git ps && git ps --tags && git poo $branch && git dlb $branch; }; _"
  apr = "!_() { set -x; branch=$(git brn) && token=$(cat ~/.github_git_alias_auth_token) && if [ \"$branch\" == \"master\" ]; then echo \"branch is master, cannot create pull request.\"; exit 1; fi && curl -H \"Authorization: token $token\" -H \"Content-Type: application/json\" --data \"{ \\\"title\\\": \\\"$branch\\\", \\\"body\\\": \\\"$(git log --oneline --abbrev-commit $branch ^master --no-merges | sed 's/$/\\\\\\\\\\\\n/' | tr -d '\\n')\\\", \\\"head\\\": \\\"$branch\\\", \\\"base\\\": \\\"master\\\", \\\"requested_reviewers\\\": [$(cat ~/.github_git_alias_assignee_list)] }\" https://api.github.com/repos/$(git account)/$(git repo)/pulls; }; _"
  ab = "!_() { branch=$(git brn) && if [ \"$branch\" != \"master\" ]; then echo \"cannot start a branch from anything else other than master\"; exit 1; fi && git pl && git b \"$1\" && git co \"$1\" && git ps -u origin \"$1\"; }; _"
[branch]
  autosetuprebase = always
[filter "hawser"]
  clean = git hawser clean %f
  smudge = git hawser smudge %f
  required = true

[pager]
  log = diff-highlight | less
  show = diff-highlight | less
  diff = diff-highlight | less

[filter "trimWhitespace"]
  clean = git-stripspace
